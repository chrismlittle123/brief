# Brief - V3 Specification

> Fill in the gaps, keep it brief.

V3 builds on the [V2 spec](./v2.md) with a conversational voice agent powered by LiveKit and a Slack-initiated check-in flow.

## New Features

### 1. LiveKit Voice Agent

Replace the current record-then-transcribe flow with a real-time conversational AI agent that interviews the user through their weekly update.

**How it works:**

- User opens a voice session (from Slack or directly)
- A LiveKit voice agent greets them and asks the 4 core questions one by one
- The user answers conversationally â€” the agent listens, acknowledges, and moves on
- If an answer is vague, the agent asks a brief follow-up to get specifics
- After all 4 questions, the agent summarizes what it heard and asks if anything is missing
- The session ends and a structured report is generated from the conversation transcript

**The 4 questions (agent asks these conversationally):**

1. "What did you get done this week?"
2. "Any challenges? How did you handle them?"
3. "What's the plan for next week?"
4. "How's the client or stakeholder feeling?"

**Architecture:**

```
Browser (LiveKit Client SDK)
    â†• WebRTC audio
LiveKit Server (LiveKit Cloud or self-hosted)
    â†•
LiveKit Agents Framework (Python)
    â”œâ”€â”€ STT: Deepgram (or OpenAI Whisper)
    â”œâ”€â”€ LLM: OpenAI GPT-4o (conversation logic)
    â””â”€â”€ TTS: OpenAI TTS (or ElevenLabs)
```

**Agent behaviour:**

- Warm, concise, professional tone â€” not robotic, not overly chatty
- Keeps the conversation moving â€” each question should take 30â€“60 seconds
- Entire session targets under 5 minutes
- If the user goes off-topic, gently steers back
- Handles interruptions gracefully (barge-in support via LiveKit)
- The agent has context about who the user is (name, team) passed via room metadata

### 1a. Session Resilience & Resume

The voice session is designed for the "airpods in the park" use case. Real-world interruptions â€” phone calls, lost signal, locking your phone â€” should never lose your progress.

**State saving:**

- The agent saves conversation state to the backend after each completed question-answer exchange
- State includes: which questions have been answered, the transcript so far, and any extracted data
- State is persisted server-side, keyed by `sessionId`

**Session state model:**

```
{
  sessionId: "abc123",
  userId: "chris@palindrom.ai",
  weekOf: "2025-01-27",
  status: "in_progress",      // pending | in_progress | completed
  currentQuestion: 3,          // 1-indexed, next question to ask
  answers: [
    { question: 1, transcript: "...", completedAt: "..." },
    { question: 2, transcript: "...", completedAt: "..." }
  ],
  fullTranscript: "...",       // running transcript of entire conversation
  createdAt: "...",
  lastActiveAt: "..."          // updated on each interaction
}
```

**Resume flow:**

1. User disconnects mid-session (phone call, signal loss, screen lock, crash)
2. The session remains in `in_progress` state on the server
3. User taps the same Slack button (or bookmarked URL) to come back
4. Backend sees the session exists and is resumable
5. A new LiveKit room is created, agent joins with the saved state as context
6. Agent greets them back: *"Hey Chris, welcome back. We covered your accomplishments and challenges â€” let's pick up with what's planned for next week."*
7. Conversation continues from where it left off

**Resume window:**

- Sessions are resumable for 24 hours (matches the signed token expiry)
- After 24 hours, the session expires â€” user needs a new link
- If a session has answers for all 4 questions but wasn't formally completed, it auto-generates the report on expiry (so partial work is never lost)

**What triggers a save:**

- Agent completes a question-answer exchange â†’ save after each one
- Agent detects the user's answer is substantive enough to record
- User explicitly says "hold on" or "I need to pause" â†’ agent acknowledges and saves
- WebRTC connection drops â†’ last state is already saved (saves happen after each Q&A, not on disconnect)

### 1b. Background Audio & Screen Lock Handling

**The problem:** iOS Safari suspends WebRTC when the browser tab goes to background or the screen locks. This is a hard OS-level restriction â€” no web API can override it. Android is more permissive but still unreliable.

**V3 approach (web-only, pragmatic):**

1. **Wake Lock API**: Request a screen wake lock when the call starts. This prevents the screen from auto-dimming while the user is walking/talking. The screen stays on in their pocket.

2. **Graceful disconnection**: If the connection drops (user locks phone, takes a call, etc.), the session state is already saved. No progress is lost.

3. **Fast reconnect**: When the user comes back, the page detects the stale connection and shows a single "Resume" button. One tap â†’ back in the conversation.

4. **Audio focus hint**: On session start, show a brief toast: *"Keep your screen on for uninterrupted audio. Your progress is saved if you need to step away."*

**What this means in practice (airpods in the park):**

| Scenario | What happens |
|----------|-------------|
| Screen stays on (Wake Lock active) | Uninterrupted â€” full conversation flows |
| User manually locks phone | WebRTC drops. Come back, tap Resume, pick up where you left off |
| Incoming phone call | WebRTC drops. After the call, return to browser, tap Resume |
| Lose signal briefly | LiveKit reconnects automatically (built-in ICE restart). If it fails, Resume flow |
| Slack WebView blocks WebRTC | "Open in browser" fallback link shown immediately |
| App killed / crash | Return to URL, Resume flow picks up at last saved question |

**Future: Native app wrapper (post-v3)**

A thin native iOS/Android app (React Native, Expo, or Capacitor) with a background audio entitlement would solve the screen-lock problem completely. The audio session stays alive in the background, and the OS shows a green pill / notification bar. This is the only way to get true "pocket mode" on iOS. Out of scope for v3, but the session architecture is designed to support it â€” the native app would connect to the same LiveKit rooms and use the same backend APIs.

**Voice session UI (`/call/[sessionId]`):**

- Minimal, mobile-first interface
- Shows: agent avatar/waveform, current question number (1/4), mute button, end call button
- No login screen â€” identity comes from the signed token in the URL
- Auto-connects on page load (requests mic permission, then starts)
- When the session ends, transitions to the report review screen

**After the call:**

- The full conversation transcript is processed by GPT-4o to extract the structured report (same format as v1/v2: TL;DR, This Week, Challenges, Next Week, Client Pulse, Status)
- User sees the generated report and can refine it (existing refinement flow)
- One-click save to Notion (existing flow)

### 2. Slack-Initiated Check-in Flow

Upgrade the Shame Bot from a text-only webhook to a Slack app that sends interactive messages with a direct link to start a voice session.

**What changes:**

- Replace the Slack incoming webhook with a proper Slack app (for Block Kit messages with buttons)
- The shame bot message now includes a "Start Check-in" button
- Clicking the button opens the voice agent session in the browser
- The URL contains a signed token so the user is authenticated automatically

**Slack message format:**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Hey Chris, time for your weekly update.     â”‚
â”‚                                              â”‚
â”‚  It takes ~3 minutes â€” just talk through     â”‚
â”‚  what you've been up to.                     â”‚
â”‚                                              â”‚
â”‚  [ Start Check-in ]  â† opens voice session   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

The button URL: `https://brief.palindrom.ai/call/[sessionId]?token=[signedToken]`

**Slack app setup:**

- Bot token scopes: `chat:write`, `users:read`, `users:read.email`
- The app posts to a team channel (like today's shame bot) and/or sends DMs
- Escalation levels remain (GENTLE, MEDIUM, FULL_ROAST) â€” the message copy changes but the button is always present
- When all team members have submitted, the celebration message is posted (no button needed)

**DM flow (new):**

In addition to channel messages, the bot sends a direct message to each team member who hasn't submitted:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Hey Chris â€” quick reminder to submit your   â”‚
â”‚  weekly update.                              â”‚
â”‚                                              â”‚
â”‚  [ Start Check-in ]                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

This is more effective on mobile â€” the user gets a Slack notification, taps it, taps the button, and they're talking to the agent.

### 3. Signed Token Authentication

When a user clicks the Slack button, they should land in the voice session immediately â€” no login screen.

**How it works:**

1. When the shame bot generates a message for a specific user, it creates a signed JWT containing:
   - `sub`: user email
   - `name`: user display name
   - `team`: team identifier
   - `sessionId`: unique session ID for this check-in
   - `weekOf`: the Monday date for this update
   - `exp`: expiry (24 hours)

2. The JWT is signed with a server-side secret (`BRIEF_SESSION_SECRET`)

3. The URL includes the token: `https://brief.palindrom.ai/call/[sessionId]?token=[jwt]`

4. When the page loads, the backend:
   - Verifies the JWT signature and expiry
   - Extracts user identity (no Clerk session needed)
   - Creates a LiveKit room and generates a LiveKit participant token
   - Returns the LiveKit connection details to the frontend

5. The frontend connects to LiveKit and the conversation begins

**Fallback:** If the token is expired or invalid, redirect to the normal Clerk login flow, then back to the session.

**Security considerations:**

- Tokens are single-use per session (sessionId is unique)
- 24-hour expiry prevents stale links from being reused
- The JWT secret is separate from other app secrets
- Tokens are generated server-side only â€” never exposed to the client before the Slack message

### 4. Voice-First Review & Editing

After the agent interview, the user stays in a voice-driven experience for reviewing and editing their report. No reading walls of text on a phone screen.

**AI read-back:**

Once the report is generated, the agent reads it back to the user aloud using TTS. The user picks a playback speed before it starts:

- **1x** â€” normal pace, good for careful review
- **1.5x** â€” default, natural but brisk
- **2x** â€” speed-run, for people who just want to confirm nothing's wrong

The speed selector is a simple 3-button toggle on screen. The agent reads the full structured report section by section:

> *"Here's your update. TL;DR: You shipped the new onboarding flow and resolved the API latency issue. This week â€” you completed the onboarding redesign, paired with Faycal on the payments integration, and fixed the P1 latency bug in the search endpoint..."*

**Voice editing:**

After read-back (or at any point â€” the user can interrupt), the user edits by talking:

- *"Change the TL;DR to mention the client demo"*
- *"Remove the part about the latency bug, that was last week"*
- *"Add that I'm blocked on the design review from Jon"*
- *"Change status from On Track to At Risk"*

The agent processes the instruction, updates the report, and reads back just the changed section for confirmation. This loops until the user says they're happy.

**Voice commands during review:**

| Command | Action |
|---------|--------|
| "Read it again" | Full read-back at current speed |
| "Read the challenges section" | Read-back of a specific section |
| "Slower" / "Faster" | Adjust playback speed |
| "Change [section] to [content]" | Edit a specific section |
| "Add [content] to [section]" | Append to a section |
| "Remove [content]" | Delete from report |
| "Sounds good" / "Save it" | Confirm and save to Notion |
| "Start over" | Regenerate report from transcript |

**Flow:**

```
Agent interview complete
    â†“
"Here's your report. Want me to read it back?"
    â†“
User picks speed (1x / 1.5x / 2x)
    â†“
Agent reads report aloud
    â†“
"Any changes?"
    â†“
User speaks edits (or says "sounds good")
    â†“
Agent reads back changed sections
    â†“
Loop until confirmed
    â†“
Save to Notion
```

The entire flow â€” from Slack tap to saved report â€” can be done without ever looking at the screen.

### 5. Comms Receiver â€” Manager/CEO Output

Reports aren't just saved to Notion. The people who need to read them â€” managers, leads, CEOs â€” get them delivered via Slack in the format they prefer.

**Slack delivery to receivers:**

When a team member saves their report, the Slack app posts to a configured channel (or DMs specific receivers) with two consumption options:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ðŸ“‹ Weekly Update â€” Chris Little                  â”‚
â”‚  Week of Jan 27, 2025 Â· Status: On Track         â”‚
â”‚                                                    â”‚
â”‚  TL;DR: Shipped the onboarding flow and resolved  â”‚
â”‚  the API latency issue. Client demo went well.    â”‚
â”‚                                                    â”‚
â”‚  [ Read Full Report ]    [ Listen to Podcast ]    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Option 1: Read Full Report (signed URL)**

- Button opens `https://brief.palindrom.ai/report/[reportId]?token=[signedToken]`
- Signed token grants read-only access â€” no login required
- Clean, formatted page showing the full structured report
- Token expires after 7 days

**Option 2: Listen as Podcast (audio version)**

- Button opens `https://brief.palindrom.ai/report/[reportId]/listen?token=[signedToken]`
- The report is pre-rendered as audio using TTS (generated when the report is saved)
- Minimal player UI with:
  - Play / pause
  - Playback speed: **1x / 1.5x / 2x / 3x**
  - Progress bar
  - Duration (typically 60â€“90 seconds)
- Works inline on mobile â€” the receiver can listen while commuting, walking, etc.

**Audio generation:**

- When a report is saved, the backend generates an audio file using OpenAI TTS (or ElevenLabs)
- The script is a natural narration of the report, not a robotic reading of bullet points:

  > *"Chris's update for the week of January 27th. The big wins this week were shipping the new onboarding flow and resolving the API latency issue. The client demo on Wednesday went well â€” stakeholders are feeling positive. One challenge: the design review from Jon is still pending, which could slow down next week's work. Looking ahead, the priorities are..."*

- Audio is stored as a static file (S3 / Vercel Blob / R2) and served via CDN
- Generated once per report, cached permanently

**Receiver configuration:**

- Receivers are configured per team (e.g., "send Chris's updates to #leadership and DM to faycal@palindrom.ai")
- Configurable in the Brief admin or via environment variable initially:

```
BRIEF_RECEIVERS=channel:#leadership,dm:faycal@palindrom.ai,dm:jon@palindrom.ai
```

**Digest mode (optional, future):**

Instead of one message per report, receivers can opt into a weekly digest â€” a single Slack message on Monday morning with all team updates, and a combined podcast that reads through everyone's update back-to-back with transitions:

> *"Here are the team updates for the week of January 27th. Starting with Chris..."*

This is noted as a future enhancement â€” v3 ships with individual report delivery.

## Updated Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Slack App   â”‚â”€â”€â”€â”€â†’â”‚  Brief Backend    â”‚â”€â”€â”€â”€â†’â”‚  LiveKit Cloud  â”‚
â”‚  (Bot)       â”‚â†â”€â”€â”€â”€â”‚  (Next.js API)    â”‚     â”‚  (WebRTC SFU)   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
   â†‘  sends to            â”‚                         â”‚
   â”‚  receivers            â”‚                         â†•
   â”‚                       â”‚                  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚                       â”‚                  â”‚  LiveKit Agent   â”‚
   â”‚                       â”‚                  â”‚  (Python)        â”‚
   â”‚                       â”‚                  â”‚  â”œâ”€â”€ STT         â”‚
   â”‚                       â”‚                  â”‚  â”œâ”€â”€ LLM         â”‚
   â”‚                       â”‚                  â”‚  â””â”€â”€ TTS         â”‚
   â”‚                       â”‚                  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
   â”‚                       â”‚
   â”‚                â”Œâ”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”
   â”‚                â”‚      â”‚       â”‚
   â”‚          â”Œâ”€â”€â”€â”€â”€â”´â”€â”€â” â”Œâ”€â”´â”€â”€â”€â”€â” â”Œâ”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚          â”‚ Notion â”‚ â”‚OpenAIâ”‚ â”‚ Audio Store â”‚
   â”‚          â”‚ (save) â”‚ â”‚(LLM) â”‚ â”‚ (S3/R2)    â”‚
   â”‚          â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
   â”‚                        â”‚
   â”‚                   TTS for podcast
   â”‚                   narration + review
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
```

**Flow:**

```
1. Shame bot sends Slack message with signed URL
2. User clicks button â†’ browser opens /call/[sessionId]?token=[jwt]
3. Backend verifies token, creates LiveKit room, returns connection info
4. Frontend connects to LiveKit room via WebRTC
5. LiveKit Agent joins room, starts conversation
6. Agent asks 4 questions, user answers by voice
7. Session ends â†’ transcript sent to GPT-4o for report generation
8. Agent reads report back to user at chosen speed (1x/1.5x/2x)
9. User edits by voice ("change the TL;DR to...", "remove the part about...")
10. User confirms â†’ report saved to Notion
11. Backend generates podcast audio (TTS narration of report)
12. Slack app sends report to configured receivers (read link + podcast link)
```

## New API Routes

| Route | Method | Purpose |
|-------|--------|---------|
| `/api/session/create` | POST | Create a new voice session (generates sessionId, signed token) |
| `/api/session/[sessionId]/join` | GET | Verify token, create LiveKit room, return participant token |
| `/api/session/[sessionId]/state` | GET | Fetch current session state (for resume) |
| `/api/session/[sessionId]/state` | PATCH | Save agent's progress (question answers, transcript) |
| `/api/session/[sessionId]/complete` | POST | Receive final transcript from agent, generate report |
| `/api/session/[sessionId]/report` | GET | Fetch generated report for review |
| `/api/report/[reportId]/audio` | POST | Generate podcast audio from a saved report (TTS narration) |
| `/api/report/[reportId]/audio` | GET | Stream the generated podcast audio file |
| `/api/report/[reportId]` | GET | Fetch report for read-only viewer (signed token auth) |
| `/api/slack/notify` | POST | Send check-in reminders via Slack app (replaces shame-bot) |
| `/api/slack/deliver` | POST | Send completed report to configured receivers via Slack |

Routes removed:

| Route | Reason |
|-------|--------|
| `/api/shame-bot` | Replaced by `/api/slack/notify` |
| `/api/transcribe` | No longer needed â€” LiveKit agent handles STT in real-time |

Routes unchanged:

| Route | Notes |
|-------|-------|
| `/api/generate-report` | Still used to generate structured report from transcript |
| `/api/refine-report` | Still used for post-call report editing |
| `/api/save-to-notion` | Unchanged |

## New Pages

| Route | Purpose |
|-------|---------|
| `/call/[sessionId]` | Voice agent session UI (interview + voice review + voice editing) |
| `/call/[sessionId]/review` | Visual report review fallback (reuses existing report UI) |
| `/report/[reportId]` | Read-only report viewer for receivers (signed token auth) |
| `/report/[reportId]/listen` | Podcast player for receivers (signed token auth) |

Existing pages (`/checkin`, `/checkin/text`) remain as alternative input methods.

## LiveKit Agent (Python)

The voice agent runs as a separate service using the [LiveKit Agents Framework](https://docs.livekit.io/agents/).

**Key details:**

- Language: Python (LiveKit Agents SDK is Python-first)
- Hosted separately from the Next.js app (e.g., Railway, Fly.io, or a VM)
- Connects to LiveKit Cloud â€” dispatched automatically when a room is created
- Uses room metadata to receive user context (name, team, weekOf)

**Agent pipeline:**

```python
# Pseudocode
agent = VoicePipelineAgent(
    stt=deepgram.STT(),
    llm=openai.LLM(model="gpt-4o"),
    tts=openai.TTS(voice="alloy"),
)
```

**System prompt (summary):**

> You are Brief, a friendly weekly check-in assistant. You're interviewing {name} for their weekly status update (week of {weekOf}). Ask 4 questions one at a time. Keep it conversational and concise. If an answer is vague, ask one follow-up. After all questions, summarize what you heard and confirm. Then end the session.

**Transcript handling:**

- The agent collects the full conversation transcript
- On session end, it sends the transcript to the Brief backend via `/api/session/[sessionId]/complete`
- The backend processes it through the existing report generation pipeline

## Mobile Experience

The Slack â†’ voice agent flow is designed to work well on phones:

1. **Notification**: User gets a Slack DM notification
2. **One tap**: Opens Slack, sees the message
3. **Second tap**: Taps "Start Check-in" button
4. **Browser opens**: `/call/[sessionId]?token=[jwt]` loads
5. **Mic permission**: Browser prompts for microphone (one-time)
6. **Talking**: Agent greets them, conversation starts
7. **Done**: Report appears, tap "Save to Notion"

**Mobile UI considerations:**

- Large, tappable buttons
- No scrolling needed during the call â€” everything visible in viewport
- Works in both iOS Safari and Android Chrome
- Handles in-app browser (Slack WebView) â€” if WebRTC fails, show a "Open in browser" fallback link
- Wakelock to prevent screen from sleeping during the call

## Updated Environment Variables

| Variable | Purpose | New/Changed/Removed |
|----------|---------|---------------------|
| `LIVEKIT_API_KEY` | LiveKit server API key | New |
| `LIVEKIT_API_SECRET` | LiveKit server API secret | New |
| `LIVEKIT_URL` | LiveKit server WebSocket URL | New |
| `BRIEF_SESSION_SECRET` | JWT signing secret for session tokens | New |
| `SLACK_BOT_TOKEN` | Slack app bot token (replaces webhook) | New |
| `SLACK_SIGNING_SECRET` | Slack request signature verification | New |
| `SLACK_WEBHOOK_URL` | _(removed)_ | Removed |
| `DEEPGRAM_API_KEY` | Deepgram STT API key (if using Deepgram) | New |
| `AUDIO_STORAGE_BUCKET` | S3/R2 bucket for podcast audio files | New |
| `AUDIO_STORAGE_ACCESS_KEY` | Storage access key | New |
| `AUDIO_STORAGE_SECRET_KEY` | Storage secret key | New |
| `BRIEF_RECEIVERS` | Receiver config (channel:#leadership,dm:user@co.com) | New |
| `OPENAI_API_KEY` | Unchanged (used for LLM + TTS + report generation) | - |
| `NOTION_API_KEY` | Unchanged | - |
| `NOTION_DATABASE_ID` | Unchanged | - |
| `NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY` | Unchanged | - |
| `CLERK_SECRET_KEY` | Unchanged | - |

## Updated User Flow

**Slack-initiated (primary v3 flow):**

1. Shame bot sends Slack message/DM with "Start Check-in" button
2. User taps button â†’ browser opens voice session
3. Agent asks 4 questions conversationally (~3 min)
4. Report is generated from conversation
5. Agent reads report back at user's chosen speed (1x / 1.5x / 2x)
6. User edits by voice until satisfied
7. User says "save it" â†’ report saved to Notion
8. Podcast audio generated from report
9. Slack app delivers report to receivers (read link + podcast link)

**Receiver experience:**

1. Manager/CEO gets Slack message with report summary
2. Taps "Read Full Report" â†’ signed URL opens formatted report (no login)
3. Or taps "Listen to Podcast" â†’ audio player with speed controls (1x / 1.5x / 2x / 3x)

**Direct access (existing flows still work):**

- `/checkin` â€” voice recording flow (v1)
- `/checkin/text` â€” text input flow (v1)
- `/call/new` â€” start a new voice agent session directly (v3, requires Clerk auth)
